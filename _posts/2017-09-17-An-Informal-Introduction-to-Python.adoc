= არაფორმარული შესავალი პითონზე. ნაწილი 4
:compat mode: true
:hp-alt-title: An Informal Introduction to Python

შემდგომ მაგალითებში შეტანა და გამოტანა განსხვავდება მოთხოვნათა არსებობით ან არ არსებობით (>>> და ...) გავიხსენოთ მაგალითები, ნებისმიერი ტექსტი უნდა შეიყვანოთ გამოძახების შემდეგ. განაცხადის ეკრანზე გამოჩენის შემდეგ თუ ხაზები არ გამოჩნდება მაშინ ისინი გამოიძახება interpreter-ის საშუალებით. მიაქციეთ ყურადღება, რომ ცალკეულ სტროფებზე მეორადი გამოძახება ნიშნავს ცარიელი სტრიქონის შეყვანის საჭიროებას; ეს გამოიყენება რამოდენიმე სტროფის ბრძანების დასრულებისთვის. 
ამ გაკვეთილებში მოცემული ყველა მაგალითი, ინტერაქტიულ რეჟიმში შეყვანის ჩათვლით,  მოიცავს კომენტარებს. კომენტარები Python-ში იწყება # და გრძელდება ხაზის ბოლომდე. კომენტარი შესაძლოა გამოჩნდეს ხაზის დასაწყისში, გამოტოვებისას ან კოდში, მაგრამ არა literal-ის ხაზს შიგნით, რადგან კომენტარი განმარტავს კოდს,რომელიც არ არის ინტერპრეტირებული  Python-ის მიერ, მაგალითების მოყვანისას ის შესაძლოა იყოს გამოტოვებული. 
მაგალითად:

 # this is the first comment
 spam = 1  # and this is the second comment
		   # ... and now a third!
 text = "# This is not a comment because it's inside quotes."

== 1. პითონის როგორც კალკულატორის გამოყენება

მოდით ვცადოთ Python-ის რამოდენიმე მარტივი ბრძანება. ჩართეთ ინტერპრეტატორი და დაელოდეთ პირვანდელ მოთხოვნას >>>. (ეს პროცესი არ წაგართმევთ დიდ დროს)

== 2. რიცხვები

თქვენ შეგიძლიათ ინტერპრეტატორის გამოიყენება, როგორც კალკულატორის: შეიყვანეთ სასურველი ლოგიკური გამოსახულება და ის გამოგითვლით მნიშვნელობას.   ლოგიკური გამოსახულების სინტაქსი მარტივია: ოპერატორი +, -, * და / ისინი მუშაობენ, ისე როგორც სხვა პროგრამულ ენაში (მაგალითად: პასკალის ან C), დიდი ბრჭყალები (()) შესაძლოა გამოყენებულიქნას დაჯგუფებებისთვის. მაგალითად:

 >>> 2 + 2
 4
 >>> 50 – 5 * 6
 20
 >>> (50 – 5 * 6) / 4
 5.0
 >>> 8 / 5 # გაყოფა ყოველთვის აბრუნებს ციფრებს საწყის ეტაპზე
 1.6

მთელი რიცხვები (ე.ი 2, 4, 20) int ტიპის არიან, წილადი რიცხვები (ე.ი. 5.0, 1.6) მიეკუთვნებიან float ტიპს. მოგვიანებით ჩვენ შევიტყობთ უფრო მეტს რიცხვითი ტიპების შესახებ. 

გაყოფა (/) ყოველთვის აბრუნებს მცოცავ რიცხვებს(float). იმისათვის, რომ გაყოფის დროს მივიღოთ მთელი რიცხვი (და არა წილადი) ჩვენ შეგვიძლია გამოვიყენოთ // ოპერატორი; ნაშთის გამოსათვლელად გამოიყენეთ %:

 >>> 17 / 3 # კლასიკური გაყოფა აბრუნებს მცოცავ რიცხვებს
 5.666666666666667
 >>>
 >>> 17 // 3 # გამყოფის ძირი აგდებს წილადის ნაწილს
 5
 >>> 17 % 3 # ოპერატირი % აბრუნებს გაყოფიდან დარჩენილ ნაშთს 
 2
 >>> 5 * 3 + 2 # შედეგი * გამყოფი + დარჩენილი ნაშთი
 17

პითონში შეგიძლიათ გამოიყენოთ ** ოპერატორი ხარისხის გამოსათვლელად:

 >>> 5 ** 2 # 5 კვადრატში
 25
 >>> 2 ** 7 # 2 ხარისხად 7
 128

ტოლობის ნიშანი (=) გამოიყენება ცვლადის მნიშვნელობის მისანიჭებლად ამის შემდეგ, შედეგი არ გამოჩნდება მომდევნო ინტერაქტიულ მოთხოვნამდე(ანუ ცვლადის გამოძახებამდე): 

 >>> width = 20
 >>> height = 5 * 9
 >>> width * height
 900

თუ ცვლადი არ არის “განსაზღვრული(გამოცხადებული)” (ენიჭება მნიშვნელობა); მისი გამოყენების მცდელობა მოგცემთ შეცდომას: 

 >>> n # მცდელობა გამოიძახოთ ცვლადი რომელიც არ არის აღწერილი
 Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 NameError: name 'n' is not defined

არსებობს სრული მხარდაჭერა მცოცავი რიცხვებისთვის; ოპერატორი შერეული სხვადასხვა ობიექტების ტიპებთან ჯამში გვაძლევს სრულ ობიექტს მცოცავ რიცხვში: 

 >>> 3 * 3.75 / 1.5
 7.5
 >>> 7.0 / 2
 3.5

ინტერაქტიულ რეჟიმში ბოლოს გამოცხადებულ გამოსახულებებს ენიჭებათ ცვლადი _. ყოველივე ეს ნიშნავს იმას, რომ თქვენ პითონს იყენებთ, როგორც სამაგიდო კალკულატორს,  ეს გარკვეულწილად გაადვილებს გააგრძელოთ გამთვლები, მაგალითად:

 >>> tax = 12.5 / 100
 >>> price = 100.50
 >>> price * tax
 12.5625
 >>> price + _
 113.0625
 >>> round(_, 2)
 113.06

ეს ცვლადი უნდა განიხილებოდეს როგორც მხოლოდ მომხმარებლის მიერ წაკითხული. ეს არ ნიშნავს იმას, რომ ჩვენ მკაფიოდ მივანიჭეთ მას ეს მნიშვნელობა - თქვენ შეგიძლიათ შექმნათ  დამოუკიდებელი ადგილობრივი ცვლადი იმავე სახელწოდებით, რომელიც ჩაანაცვლებს ჩაშენებულ ცვლადს თავისი ჯადოსნური თავისებურებებით. 
int და float-ის გარდა დამატებით, პითონს გააჩნია სხვა ციფრული ტიპების მხარდაჭერაც,  ისეთების როგორიცაა  Decimal და Fraction-ი. პითონს ასევე აქვს ჩაშენებული კომპლექსური რიცხვების მხარდაჭერა, იგი გამოიყენება j ან  J სუფიქსისთვის, რომ მიუთითოს წარმოსახვითი ნაწილი (მაგალითად 3+5j). 

== 3. სტრიქონები

ციფრების გარდა პითონს შეუძლია სტრიქონებთან მუშაობა, რომლებიც შესაძლოა გამოხატულ იქნან რამოდენიმე სიტყვით და შესაძლოა იყოს ჩაწერილი ერთმაგ ბრჭყალებში (’...’) ან ორმაგ ბრჭყალებში ("...") ერთი და იმავე შედეგით.  \ ნიშანი შეიძლება გამოყენებულ იქნას სპეციალური ციტატების ჩასმისას: 

 >>> 'spam eggs' # ერთმაგი ბრჭყალით
 'spam eggs'
 >>> 'doesn\'t' # სპეცილური ციტატის ჩასმისას \' ნიშნის გამოყენება ერთმაგ ბრჭყალში  
 "doesn't"
 >>> "doesn't" # ორმაგი ბრჭყალით
 "doesn't"
 >>> '"Yes," he said.'
 '"Yes," he said.'
 >>> "\"Yes,\" he said."
 '"Yes," he said.'
 >>> '"Isn\'t," she said.'
 '"Isn\'t," she said.'

ინტერაქტიულ ინტერპრეტატორში გამავალი სტრიქონი მოთავსებულია ბრჭყალებში და სპეციალურ სიმბოლოებში. მიუხედავად იმისა, რომ ეს შეიძლება ზოგჯერ გამოიყურებოდეს როგორც განსხვავებული  შეყვანის მეთოდი (შერეული კოდირებები შესაძლოა შეიცვალონ), ორი სტრიქონი რჩება ეკვივალენტური. სტრიქონი მოთავსებულია ორ ბრჭყალში მაშინ, როდესაც სტრიქონი შეიცავს ერთმაგ აპოსტროფს და არა ორმაგს, წინააღმდეგ შემთხვევაში ის მოთავსებული იქნება ერთმაგ ბრჭყალში. print() ფუნცია გახდის გამოსატან ჩანაწერს წაიკითხვადს, ზედმეტი ბრჭყალების და სიმბოლოების გარეშე:

 >>> '"Isn\'t," she said.'
 '"Isn\'t," she said.'
 >>> print('"Isn\'t," she said.')
 "Isn't," she said.
 >>> s = 'First line.\nSecond line.' # \n გულისხმობს ახალ ხაზზე გადასვლას
 >>> s # print() ფუნქციის გარეშე, \n შედის გამოსატან ჩანაწერში
 'First line.\nSecond line.'
 >>> print(s) # print() ფუნქციის გამოყენებით, \n უზრუნველყოფს ახალ ხაზზე გადასვლას 
 First line.
 Second line.

თუ თქვენ არ გინდათ \ სიმბოლოს როგორც ინტერპრეტირებული სპეციალური სიმბოლოს სახით შეყვანა, მაშინ უბრალოდ ჩაწერეთ  r პირველი წინადადების ჩაწერამდე:

 >>> print('C:\some\name') # აქ \n უზრუნველყოფს ახალ ხაზზე გადასვლას!
 C:\some
 ame
 >>> print(r'C:\some\name') # r იწერება ბრჭყალის წინ
 C:\some\name

სტრიქონის ლიტერალები შესაძლოა იკავებდნენ რამოდენიმე სტროფს. ერთ-ერთი გზა არის გამოვიყენოთ სამმაგი ბრჭყალები: """...""" ან '''...'''. სტროფი ავტომატურად სრულდება. ასე რომ არ მოხდეს, სტროფის ბოლოს უნდა დავსვათ \ . მაგალითად:

 print("""\
 Usage: thingy [OPTIONS]
 -h Display this usage message
 -H hostname Hostname to connect to
 """)

 Usage: thingy [OPTIONS]
 -h Display this usage message
 -H hostname Hostname to connect to

განმარტება (სხვა კომპიუტერული ენებისგან განსხვავებით სპეციალურ სიმბოლოებს როგორიცაა  \n გააჩნია იგივე მნიშვნელობა, რაც (’...’) და ორმაგ ("...") ბრჭყალებს. ამ ორს შორის  ერთადერთი განსხვავება ისაა, რომ ერთმაგ ბრჭყალში თქვენ არ გესაჭიროებათ  " სიმბოლოს  ჩაწერა (თუმცა სავალდებულოა \’ სიმბოლო).

თქვენ შეგიძლიათ გააერთიანოთ სტრიქონები(შეკრიბოთ) + ოპერატორის და *: განმეორებითი სიმბოლოს დახმარებით:

 >>> # 3 ჯერ 'un', დამატებული 'ium'
 >>> 3 * 'un' + 'ium'
 'unununium'

ორი ერთმანეთთან ახლოს მდგარი სტრიქონის ლიტერალი (ბრჭყალებში მოთავსებული) ავტომატურად ერთიანდება:

 >>> 'Py' 'thon'
 'Python'

ეს ფუნქცია მუშაობს მხოლოდ ორ ლიტერალთან თუმცა, არა ცვლადებთან და გამოსახულებებთან:

 >>> prefix = 'Py'
 >>> prefix 'thon' # არ შეიძლება გააერთიანდეს ცვლადი და სტრიქონის ლიტერალი
 ...
 SyntaxError: invalid syntax
 >>> ('un' * 3) 'ium'
 ...
 SyntaxError: invalid syntax

თუ თქვენ გინდათ ლიტერალის და ცვლადის გაერთიანება გამოიყენეთ +:

 >>> prefix + 'thon'
 'Python'

ეს ფუნქცია განსაკუთრებით სასარგებლოა მაშინ, როდესაც თქვენ გსურთ გრძელი სტროფების დაყოფა:

 >>> text = ('Put several strings within parentheses '
 ...         'to have them joined together.')
 >>> text
 'Put several strings within parentheses to have them joined together.'

სტრიქონები შესაძლოა დაიწეროს ინდექსით 0. აქ არ არსებობს გარკვეული ტიპის სიმბოლოები; სიმბოლოები უბრალოდ ერთი ზომის არიან:

 >>> word = 'Python'
 >>> word[0] # სიმბოლო პოზიციაში 0
 'P'
 >>> word[5] # სიმბოლო პოზიციაში 5
 'n'

ინდექსად ასევე შესაძლოა გამოვიყენოთ უარყოფითი ციფრები იმისათვის, რომ წერა მარჯვნიდან დავიწყოთ:

 >>> word[-1] # ბოლო სიმბოლო
 'n'
 >>> word[-2] # ბოლოდან მეორე სიმბოლო
 'o'
 >>> word[-6] # ბოლოდან მეექვსე სიმბოლო
 'P'

გაითვალისწინეთ, რომ -0 იგივეა რაც  0, უარყოფითი ინდექსები იწყება -1-დან. ინდექსაციასთან ერთად ამ ფუნქციას აქვს სტროფების დაყოფის მხარდაჭერაც. იმ დროს როდესაც ინდექსაციას ვიყენებთ სტროფების დაყოფისთვის,  მიერთება გაძლევთ საშუალებას მიიღოთ ქვესტრიქონი:

 >>> word[0:2] # სიმბოლო პოზიციიდან 0-დან - 2-მდე
 'Py'
 >>> word[2:5] # სიმბოლო პოზიციიდან 2-დან - 5-მდე
 'tho'

გაითვალისწინეთ რომ დასაწყისი ყოველთვის შეიცავს და დასარული ყოველთვის გამოტოვებულია. ეს გარანტიას იძლევა იმისა, რომ s[:i] + s[i:] სტრიქონი ყოველთვის  არის s-ის ტოლი:

 >>> word[:2] + word[2:]
 'Python'
 >>> word[:4] + word[4:]
 'Python'

სიჩუმის ინდექსს აქვს სასარგებლო უპირატესობა, რადგან გამოტოვებული პირველი ინდექსი ნულის ტოლია, გამოტოვებული მეორე ინდექსი კი მოცემული ზომის ტოლია.

 >>> word[:2] # სიმბოლო დასაწყისიდან  2-მდე
 'Py'
 >>> word[4:] # სიმბოლო მეოთხე პოზიციიდან ბოლომდე
 'on'
 >>> word[-2:] # სიმბოლო ბოლოდან მეორე პოზიციიდან ბოლომდე
 'on'

ერთ-ერთი გზა, დავიმახსოვროთ თუ როგორ მუშაობენ ინდექსები, ესაა გავიხსენოთ თუ როგორ არიან ისინი განლაგებული სიმბოლოებს შორის, მარცხენა კუთხეში მყოფი სიმბოლო ინდექსით 0. მაშინ მარჯვენა კუთხის პირველი სომბოლო n იქნება ინდექსით n, მაგალითად:

 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
 -6 -5  -4  -3  -2  -1

პირველი რიგის ციფრები სტრიქონებშI გაძლევთ პოზიციას ინდექსით  0 ... 6; მეორე რიგი კი შესაბამის უარყოფით მაჩვენებელს. ხაზი i-დან j-მდე მოიცავს i და j გვერდებს შორის მოთავსებულ ყველა სიმბოლოს. შესაბამისად დადებითი ინდექსებისთვის ჩამონახაზის სიგრძე არის ინდექსების სხვაობა, იმ შემთხვევაში თუ ორივე მოთავსებულია ფარგლებსშორის. მაგალითისთვის, სიტყვის სიგრძე [1:3] არის 2. ძალიან დიდი ინდექსის გამოყენების მცდელობა დამთავრება შეცდომით:

 >>> word[42] # სიტყვას აქვს მხოლოდ 6 სიმბოლო
 Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 IndexError: string index out of range

თუმცა, დიაპაზონს გარეთ მყოფ ინდექსებს პროგრამა ამუშავებს  კორექტულად გამყოფი ხაზების მეშვეობით:

 >>> word[4:42]
 'on'
 >>> word[42:]
 ''

პითონის სტრიქონების შეცვლა არ შეიძლება, ისინი შეუცვლელნი(immutable) არიან. ამიტომაც სტროფში ინდექსის პოზიციის მითითება იწვევს შეცდომას:

 >>> word[0] = 'J'
 ...
 TypeError: 'str' object does not support item assignment
 >>> word[2:] = 'py'
 ...
 TypeError: 'str' object does not support item assignment

თუ თქვენ გჭირდებათ განსხვავებული სტრიქონი, თქვენ უნდა შექმნათ ახალი ჩანაწერი:

 >>> 'J' + word[1:]
 'Jython'
 >>> word[:2] + 'py'
 'Pypy'

ჩაშენებული ფუნქცია len()-ი აბრუნებს სტრიქონის სიგრძეს:

 >>> s = 'supercalifragilisticexpialidocious'
 >>> len(s)
 34

იხილეთ ასევე:
Textseq სტროფები არიან თანმიმდევრობის მაგალითი, მათ გააჩნიათ საერთო მხარდაჭერა მსგავსი ოპერაციების ტიპების. სტროფების მეთოდს გააჩნია მრავალმხრივი ძირითადი ტრანსფორმაციისა და ძიების მხარდაჭრა.   Formatstrings ინფორმაცია არის სტროფების ფორმატირების შესახებ str.format(). old-string-formatting-ი არის ინფორმაცია  ძველი ფორმატირების შესახებ, მაშინ როდესაც სტროფი და მნიშვნელი არის მარცხენა მხარეს, მაშინ ოპერატორის მნიშვნელობა იქნება %. დამატებითი ინფორმაცია მოთავსებულია  ქვემოთ. 

== 4. სია

პითონმა იცის რიგი რთული(კომპლექსური) მონაცემების ტიპები,  რომელიც გამოიყენება სხვადასხვა მნიშვნელობების დაჯუფებისთვის. ყველაზე უნივერსალური გზა არის სია, რომელიც შეიძლება ჩაიწეროს როგორც მნიშვნელობების სია, რომელიც იქნება გამოყოფილი მძიმეთი(ელემენტი) და მოთავსდება კვადრატულ ფრჩხილებში. 

 >>> squares = [1, 4, 9, 16, 25]
 >>> squares
 [1, 4, 9, 16, 25]

როგორც სტრიქონები, ასევე სიაც შეიძლება დაიყოს და მიენიჭოს ინდექსი:

 >>> squares[0] # ინდექსაცია აბრუნებს სიის პირველ ელემენტს
 1
 >>> squares[-1] # ინდექსაცია აბრუნებს სიის ბოლო ელემენტს 
 25
 >>> squares[-3:] # სიის დაყოფა შესაბამისი ინდექსაციით აბრუნებს ახალ სიას
 [9, 16, 25]

დაყოფის ყველა ოპერაცია აბრუნებს ახალ სიას, რომელიც მოიცავს საჭირო ელემენტს. ეს ნიშნავს იმას, რომ შემდეგი დაყოფა აბრუნებს სიის ასლს:

 >>> squares[:]
 [1, 4, 9, 16, 25]

სიას ასევე აქვს ისეთი ოპერაციების მხარდაჭერა როგორიცაა გაერთიანება(concatenation):

 >>> squares + [36, 49, 64, 81, 100]
 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

სტრიქონებისგან განსხვავებით, რომელიც შეუცვლელია(immutable), სიის მნიშვნელობების შეცვლა(mutable) შესაძლებელია:

 >>> cubes = [1, 8, 27, 65, 125] # ზოგიერთი მნიშვნელობა არასწორია
 >>> 4 ** 3 # მაგ. 4 კუბი არის 64, და არა 65! როგორც სიაშია ნაჩვენები
 64
 >>> cubes[3] = 64 # ჩავანაცვლოთ არასწორი მნიშვნელობა
 >>> cubes
 [1, 8, 27, 64, 125]

თქვენ ასევე შეგიძლიათ სიის ბოლოს დაამატოთ ახალი ელემენტები, append() მეთოდის საშუალებით (ჩვენ შევიტყობთ მეტს ამ მეთოდის შესახებ მოგვიანებით):

 >>> cubes.append(216) # დავამატოთ 6 კუბი სიაში
 >>> cubes.append(7 ** 3) # დავამატოთ 7 კუბი სიაში
 >>> cubes
 [1, 8, 27, 64, 125, 216, 343]

ასევე შესაძლებლია დანაყოფების გადანაწილება. ამან შესაძლოა გაადიდოს სიის ზომა ან სრულიად გაასუფთავოს ის:

 >>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
 >>> letters
 ['a', 'b', 'c', 'd', 'e', 'f', 'g']
 >>> # ჩავანაცვლოთ ზოგი მნიშვნელობა
 >>> letters[2:5] = ['C', 'D', 'E']
 >>> letters
 ['a', 'b', 'C', 'D', 'E', 'f', 'g']
 >>> # ახლა ამოვიღოთ ისინი
 >>> letters[2:5] = []
 >>> letters
 ['a', 'b', 'f', 'g']
 >>> # წაშალეთ სიიდან ყველა ელემენტი და ჩაანაცვლეთ ისინი ცარიელი სიით
 >>> letters[:] = []
 >>> letters
 []

ჩაშენებული ფუნქცია len()-ი ასევე გამოიყენება სიებისთვის:

 >>> letters = ['a', 'b', 'c', 'd']
 >>> len(letters)
 4

შესძლოა ჩაშენებული სიის შექმნაც (შევქმნათ სია, რომელიც მოიცავს სხვა სიას შიგნით) მაგალითად:

 >>> a = ['a', 'b', 'c']
 >>> n = [1, 2, 3]
 >>> x = [a, n]
 >>> x
 [['a', 'b', 'c'], [1, 2, 3]]
 >>> x[0]
 ['a', 'b', 'c']
 >>> x[0][1]
 'b'

== 5. პირველი ნაბიჯები პროგრამირებისკენ

რათქმაუნდა ჩვენ პითონის გამოყენება შეგვიძლია გაცილებით უფრო რთული ამოცანებისთვის ვიდრე ეს არის ორის და ორის ერთმანეთთან დამატება. მაგალითად, შეგვიძლია დავწეროთ საწყისი ქვემიმდევრობა Fibonacci-ის რიგში შემდეგნაირად:

 >>> # Fibonacci series:
 ...    # ორი ელემენტის ჯამი განსაზღვრავს მომდევნოს
 ... a, b = 0, 1
 >>> while b < 10:
 ... 	    print(b)
 ... 	    a, b = b, a+b
 ...
 1
 1
 2
 3
 5
 8

ამ მაგალითს შემოაქვს რამოდენიმე ახალი ფუნქცია.
პირველ სტრიქონს გააჩნია უამრავი დანიშნულება: a და b ერთდროული გამოყენებით მივიღებთ ახალ მნიშვნელს 0 და 1. ბოლო სტრიქონზე მისი იგივენაირად  გამოყენება გამოხატავს იმას, რომ ყველა ელემენტზე ადრე გამოითვლება მარჯვენა მხარეს მოთავსებული მნიშვნელობები. კუთხური მნიშვნელობები გამოითვლებიან, როგორც წესი, მარცხნიდან მარჯვნივ.
ციკლი გრძელდება მანამ, სანამ არ მიიღება სწორი პასუხი (აქ: b < 10). პითონში ისევე როგორც C-ში, ნებისმიერი არანულოვანი სრული ციფრის მნიშვნელობა ზუსტია, ხოლო ნულოვანის - ცრუ. პირობა, ასევე, შეიძლება იყოს  სტრიქონის ან სიის მნიშვნელობა, ფაქტობრივად ნებისმიერი
თანმიმდევრობა; ყველაფერი არანულოვანი მნიშვნელობის მქონე არის ზუსტი, ხოლო ცარიელი თანმიმდევრობები კი ცრუ. ტესტში მოცემულია მარტივი მაგალითი. შედარების სტანდარტული ოპერატორები ჩაიწერებიან ისევე, როგორც   C-ში: C: < (ნაკლებია), > (მეტია), == (ტოლია), <= (ნაკლებია ან ტოლია), >= (მედია ან ტოლია) and != (არ უდრის).
წანაცვლების ციკლი: წანაცვლება არის Python-ის გზა გამოეყოს ჯგუფურ ოპერატორებს.  ინტერაქტიულ რეჟიმში თქვენ უნდა შეიყვანოთ სანიშნე tab ან გამოტოვება(s) ყველა წანაცვლების სტროფში. პრაქტიკაში თქვენ Python-თვის შექმნით გაცილებით უფრო რთულ შეყვანას ტექსტური რედაქტორის საშუალებით; ყველა ტექსტურ რედაქტორს გააჩნია ავტომატური  წანაცვლის ოპერატორი. როდესაც ძირითადი ოპერატორი შეგყავთ ინტერაქტიულ რეჟიმში მას თან უნდა დაერთოს ცარიელი ხაზი, იმისათვის, რომ მივუთითოთ დასასრული (რადგან სინტაქსური ანალიზატორი ვერ საზღვრავს თუ სად დაასრულეთ წინადადება). გაითვალისწინეთ, რომ ყველა ხაზი მოთავსებული საბაზო ბლოკის ფარგლებში უნდა იყოს იგივე ჯამის. 
print() ფუნქცია ბეჭდავს გადაწოდებულ მნიშვნელობებს. ეს განსხვავდება ჩვეულებრივი  გამოსახულების გამოხატვისგან (როგორც ეს უკვე გავაკეთეთ კალკულატორის მაგალითში) სხვადასხვა არგუმენტის მცურავი წერტილების და სტრიქონების რაოდენობის დამუშავებით. სტრიქონები იბეჭდება ბრჭყალების გარეშე, მათ ნაცვლად ობიექტებს შორის იწერება გამოტოვება. მშასადამე, თქვენ შეგიძლიათ დააფორმატოთ შემდეგნაირად:

 >>> i = 256*256
 >>> print('The value of i is', i)
 The value of i is 65536

უკანასკნელ არგუმენტში შეგვიძლია გამოვიყენოთ მთავარი სიტყვა, რათა თავიდან ავიცილოთ ახალი ხაზი გასვლის შემდეგ,  ან დავასრულოთ გასვლა ახალი სტროფით:

 >>> a, b = 0, 1
 >>> while b < 1000:
 ... print(b, end=',')
 ... a, b = b, a+b
 ...
 1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987
 
:hp-tags: docs[დოკუმენტაცია],python[პითონი],tutorial[გაკვეთილი]