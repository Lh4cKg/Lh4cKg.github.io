= პითონის ინტერპრეტატორის გამოყენება
:hp-alt-title: Using the Python Interpreter

== 1. ინტერპრატატორის ჩართვა

პითონის ინტერპრეტატორი ჩვევლებრივ ინსტალირდება როგორც წესი /usr/local/bin/python3.5 იმ მანქანებზე სადაც ეს შესაძლებელია, რომელიც აკეთებს putting /usr/local/bin-ში და Unix/Linux-ის shell-ი ეძებს შესაძლო path-ს რომლის მეშვეობითაც ბრძანების python3.5 შეყვანის შემდეგ შესაძლებელი ხდება პითონის ინტერპრეტატორის ჩართვა. 

Windows-ის მანქანებზე პითონის ინსტალაცია სტანდარტულად ხდება C:\Python35, რომლის შეცვლასაც შეძლებთ პროგრამის ინსტალაციის გაშვებისას.

პითონის ბრძანებების სია და აღწერა იხილეთ აქ https://docs.python.org/3/using/cmdline.html#using-on-general[Command line and environment].

== 2. არგუმენტის გადაწოდება

როდესაც ინტერპრეტატორისთვის ცნობილია ჩანაწერის სახელი და დამატებითი არგუმენტები, შემდგომ argv ცვლადი ენიჭება sys მოდულს. ეს სია თქვენთვის ხელმისაწვდომი გახდება მას შემდეგ რაც თქვენ განახორციელებთ sys მოდულის იმპორტს. სიის სიგრძე მინიმუმ ერთია; როდესაც არ არის სკრიპტი და არ არსებობს არგუმენტები, sys.argv[0] არის ცარიელი სტრიქონი. როდესაც სკრიპტს გადაეწოდება როგორც ’-’ (რაც ნიშნავს სტანდარტულ შეყვანას), sys.argv[0] გახდება ’-’. როდესაც –c  ბრძანება იქნება გამოყენებული, sys.argv[0] გახდება ’-c’. როდესაც -m მოდულს ვიყენებთ sys.argv[0]-ში ყენდება მოცემული მოდულის სრული სახელით. პარამეტრების საძიებო სისტემაში c ბრძანება ან m მოდული  არ მოქმედებს  Python Interpreter-ში დამუშავების დროს, მაგრამ დარჩა sys.argv-ში ბრძანების ან მოდულის დამუშავებისთვის.

== 3. ინტერაქტიული რეჟიმი

როდესაც ბრძანებები იკითხება tty-დან, ინტერპრეტატორი გამოიძახება ინტერაქტიულ რეჟიმში. ამ რეჟიმში იწარმოება მოთხოვნა შემდეგი ბრძანებისთვის ძირითადი სტროფებით, სტანდარტულად სამი მეტობის ნიშნით (>>>); მეორადი ხასის გაგრძელებისთვის სტანდარტულდ იყენებს სამ წერტილს (...). ინტერპრეტატორი პირველივე სტროფის დაბეჭდავამდე მისასალმებელ შეტყობინებას ბეჭდავს, რომელშიც აღნიშნულია მისი ვერსიის ნომერი და განაცხადი საავტორო უფლებების შესახებ.

$ python3.5
Python 3.5 (default, Sep 16 2015, 09:25:04)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.>>>

ხაზის გაგრძელებისთვის საჭიროა კონსტრუქციაში რამოდენიმე სიტყვის შეყვანა. მაგალითისთვის, შეხედეთ ამ if ოპერატორს:

>>> the_world_is_flat = True
>>> if the_world_is_flat:
...     print("Be careful not to fall off!")
...
Be careful not to fall off! 

იმისათვის, რომ შეიტყოთ მეტი ინტერაქტიული რეჟიმის შესახებ გადახედეთ https://docs.python.org/3/tutorial/appendix.html#tut-interac[Interactive Mode]-ს.

== 4. ინტერპრეტატორი და მისი გარემოცვა - კოდის წყაროს ენკოდირება

 სტანდარტულად, პითონის საწყისი ფაილი განიხილება, როგორც UTF-8-ში კოდირებული. ამ კოდირებაში მსოფლიოს უმეტესი ენების სიმბოლოები შესაძლებელია გამოყენებულიქნან ერთდროულად ლიტერალი სტროფის, ინდტიფიკატორის და კომენტარის, თუმცა სტანდარტულ ბიბლიოთეკაში ინდეტიფიკატორისთვის ის გამოიყენება მხოლოდ ASCII-ის სიმბოლოების სახით, რადგან არსებობს პორტატული კოდების შეთანხმება, რომელიც უნდა დაიცვას ყველა კოდმა. იმისათვის, რომ რედაქტორმა დაწეროს ყველა სიმბოლო, სწორედ მან უნდა აღიქვას UTF-8 ფაილი და ასევე უნდა გამოიყენოს შრიფტი, რომელის მხარდაჭერაც გააჩნია მოცემულ ფაილს. ამის გარდა შესაძლოა სხვა კოდირების მითითება საწყისი ფაილისთვის. ამისათვის ჩაწერეთ კიდევ ერთი განსაკუთრებული კომენტარი # დაწერის შემდეგ! ეს საჭიროა იმისათვის, რომ გაიგოთ პირვანდელი ფაილის კოდი:
# -*- coding: encoding -*-
ამ განაცხადის მეშვეობით ყველაფერი რაც არის პირვანდელ ფაილში განიხილება, როგორც კოდის მქონე, UTF-8 კოდირების ნაცვლად. შესაძლო კოდირებების სიის მოძებნას შეძლებთ Python Library Reference-ში, კოდების განყოფილებაში. მაგალითად, თუ თქვენს რედაქტორს არ გააჩნია UTF-8-ს კოდირებული ფაილების მხარდაჭერა და ის ითხოვს სხვა რაიმე კოდირებას მაგალითად  Windows-1252, უბრალოდ ჩაწერეთ:
# -*- coding: cp-1252 -*-
და უწინდებურად გამოიყენეთ ყველა Windows-1252-ის სიმბოლო საწყის ფაილში. სპეციალური კოდირების კომენტარი განლაგებული უნდა იყოს ფაილის პირველ ან მეორე სტროფზე.

:hp-tags: docs[დოკუმენტაცია],python[პითონი],tutorial[გაკვეთილი]